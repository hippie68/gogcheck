#!/bin/bash

# This script tests GOG exe and bin files for authenticity and file integrity.
# It can run 3 checks: digital signature verification, bin checksum verification,
# and Inno Setup checksum verification (testing the actual game files).
# The goal is to ensure game files haven't been tempered with by a 3rd party.
#
# The following programs are required:
#   - osslsigncode (e.g. https://github.com/mtrojnar/osslsigncode)
#   - innoextract (https://constexpr.org/innoextract/)
#
# Optional:
#   - unrar/unar to test-extract RAR archives
#   - sed for minor additional output formatting
#
# If errors have been encountered, the scripts exits with exit code 1.
#
# This script is considered work-in-progress and expected to have bugs.
# Please report any issues at https://github.com/hippie68/gogcheck
#
# USER VARIABLES: #############################################################

#debug=true # Enables appearing of debug messages
color=true

# The variables "serials", "subjects", and "issuers" are optional lists
# of known/trusted strings, which then appear colored in the signature verification.
# For "serials" and "subjects", first block is GOG, then DigiCert each.
# It is not a complete collection, and future game releases might come with new strings.
# Use this section to include additional strings seen in your known-legit files.

serials="
06F56DD38538018E9A31248796E640AB
0B2CE86937CD32092D0C003EFDF5D988
0CB6E45E4D9295AFD0DEA595E0156ACE
0DB093590538192F52B39C94119A48CB
05B5D9D6BB2960FBD330C5D6B9B7B7D2
087DE552D352D9BAF0C2B6DF6AC4C64A

0409181B5FD5BB66755343B56F955008
03019A023AFF58B16BD6D5EAE617F066
06FDF9039603ADEA000AEB3F27BBBA1B
038B96F070D9E21E55A5426792E1C83A
0FA8490615D700A0BE2176FDC5EC6DBD
039FEDEDCB795B8DED320C8919F03689
"

subjects="
/C=PL/L=Warsaw/O=GOG Sp. z o.o./CN=GOG Sp. z o.o.
/C=CY/L=Larnaca/O=GOG Limited/CN=GOG Limited
/C=CY/L=Nicosia/O=GOG Limited/CN=GOG Limited

/C=US/O=DigiCert/CN=DigiCert Timestamp Responder
/C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert Assured ID Code Signing CA-1
"

issuers="
/C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert SHA2 Assured ID Code Signing CA
/C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert Assured ID Root CA
/C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert Assured ID CA-1
"

if [[ $color == "true" ]]; then
  color_success='\033[1;92m'
  color_error='\033[91m'
  color_known='\033[32m'
  color_file='\033[1;95m'
  color_reset='\033[0;39m'
  color_debug='\033[90m'
  grep_color_success=${color_success:5:((${#color_success}-6))}
  grep_color_error=${color_error:5:((${#color_error}-6))}
  grep_color_known=${color_known:5:((${#color_known}-6))}
fi

# SCRIPT STARTS BELOW: ########################################################

# Global variables: -----------------------------------------------------------

# "okstrings" and "errorstrings" are used to highlight osslsigncode's results
okstrings="Signature verification: ok"
errorstrings="MISMATCH!!!!|MISMATCH!!!|MISMATCH|failed|Failed|No signature found."

rarcount=0 # Global number of RAR archives encountered by innocheck()
rarfiles="" # List of bins that are identified as RAR archives
errorcount=0 # Global count of errors or unexpected results
errorfiles="" # List of files that produced errors
checkcount=0 # Each exe file gets a unique number - used for tracking errors faster
exeprefix='setup_' # Overridden by command line option -F
maxdepth="-maxdepth 1" # Standard value for main loop's "find" command, unless -r set
unraroption='--gog' # Enables RAR test-extracting

# Initialization: ------------------------------------------------------------

usage() {
  echo "Usage: ${0//*\/} [options] [file(s)/folder(s)]"
  echo "Checks your GOG offline installer collection for valid digital signatures and correct checksums, making sure the files are legit and have not been tempered with."
  echo "If no files or folders are specified, the current directory will be used."
  echo "If neither the -s, -b, nor -i option is used, all checks will be run."
  echo
  echo "  The checks consist of 3 parts:"
  echo "    1. Digital signature verification for exe files"
  echo "    2. Bin file checksum verification"
  echo "    3. Inno Setup file checksum verification (actual game files packed inside exe and bin files)"
  echo
  echo "    Options:"
  echo "      -b Enables bin files checksum verification"
  echo "      -B Same as -b, but disables checksum calculation"
  echo "      -F Forces checks on all exe files (not just setup_*.exe)"
  echo "      -h Displays this help"
  echo "      -i Enables Inno Setup checksum verification"
  echo "      -I Same as -i, but disables test-extracting"
  echo "      -r Traverses directories recursively"
  echo "      -R Disables RAR test-extracting"
  echo "      -s Enables exe digital signature verification"
  echo "      -- Anything following this is considered a file/folder"
  echo
  exit 0
}

# Parsing command line arguments
while [[ $1 == "-"* && ${#1} -gt 1 ]]; do
  if [[ $1 == "--" ]]; then shift; break; fi
  for ((i=1;i<${#1};i++)); do
    case ${1:i:1} in
      b) check_binaries=1;;
      B) check_binaries=1; disable_binchecksumcalculation=true;;
      F) unset exeprefix;;
      h) usage;;
      i) check_innosetup=1;;
      I) check_innosetup=1; disable_extracting=true;;
      r) unset maxdepth;;
      R) unset unraroption;;
      s) check_signatures=1;;
      *) echo "${0//*\/}: invalid option: '${1:i:1}'"; usage;;
    esac
  done
  shift
done

[[ $1 == "" ]] && set -- . # If no arguments have been given, use current directory

# If no check has been enabled, enable all checks
if [[ $check_signatures$check_binaries$check_innosetup == "" ]]; then
  check_signatures=1 check_binaries=1 check_innosetup=1
fi

# Exit if selected, required binaries are not available
[[ $check_signatures == 1 ]] &&  ! hash osslsigncode &> /dev/null && {
  echo "osslsigncode binary not found! Which is required to verify exe signatures."
  exit 1
}
[[ $check_innosetup == 1 ]] && ! hash innoextract &> /dev/null && {
  echo "innoextract binary not found! Which is required to verify checksums of compressed files inside exe and bin files."
  echo "Download the latest version from https://constexpr.org/innoextract/"
  exit 1
}

hash sed &> /dev/null && sedfound=true # Enable optional sed if present

# Disable unrar if not available
if [[ -z ${unraroption+x} ]] && ! hash unrar &> /dev/null && ! hash unar &> /dev/null; then
  unset unraroption
  echo "unrar/unar binary not found - RAR extraction has been disabled."
fi

# Escapes all regexp metacharacters in user strings for use with grep
prepare_user_strings() {
  IFS=$'\n'
  for string in $1; do
    for char in \[ \] \( \) \. \^ \$ \? \* \+ \|; do
      string=${string//"$char"/"\\$char"}
    done
    result+="$string|"
  done
  echo "${result%|}"
}
serials=$(prepare_user_strings "$serials")
subjects=$(prepare_user_strings "$subjects")
issuers=$(prepare_user_strings "$issuers")

# Functions: ------------------------------------------------------------------

debugmessage() { [[ $debug == true ]] && echo -e "${color_debug}DEBUG MESSAGE: $1${color_reset}"; }

# Used for logging errors; argument format: "filename" "reason"
error() { ((errorcount++)); errorfiles+="[$checkcount] $1 ($2)"$'\n'; }

sigcheck() {
  echo "Running signature check..."
  result=$(osslsigncode verify "$1" 2>&1)
  returncode=$?
  # sed removes whitespace and empty lines to save space, and it removes the misleading
  # "Succeeded" message that osslsigncode creates even when there's an (perceived) error.
  echo "$result" \
     | GREP_COLOR=$grep_color_known grep --color=always -E "$serials|$subjects|$issuers|$" \
     | GREP_COLOR=$grep_color_error grep --color=always -E "$errorstrings|$" \
     | GREP_COLOR=$grep_color_success grep --color=always -E "$okstrings|$" \
     | if [[ $sedfound == true ]]; then sed -e 's/^\s\+//' -e '/^$/d' -e '/^Succeeded$/d' -e '/^------------------/d'; else cat; fi
  if [[ $returncode != 0 || $(echo "$result" | grep -o 'No signature found.') != '' ]]; then
    error "$1" "digital signature"
  fi
}

bincheck() {
  echo "Running bin check..."
  local crcstring
  crcstring=$(tac "$1" | grep -a -m 1 -i -o '[[:alnum:]]*#GOGCRCSTRING')
  debugmessage "Raw GOGCRCSTRING: $crcstring"

  # Leave if no checksums found
  if [[ $crcstring == "" ]]; then
    echo -e "No bin file checksums found."
    if compgen -G "${1%.exe}-*.bin" > /dev/null; then
      echo "However, matching bin file(s) exist:"
      for i in "${1%.exe}"-*.bin; do echo "  $i"; done
      echo -e "${color_error}Without checksums, cannot verify the bin file(s)!${color_reset}"
      error "$1" "bin checksums missing"
    else
      echo "No matching bin files found either."
      echo -e "${color_error}Is this exe a GOG installer?${color_reset}"
      error "$1" "not a GOG installer?"
    fi
    return
  fi

  crcstring=${crcstring%#GOGCRCSTRING*} # Remove the string name, leaving numbers
  local multiplier=${crcstring: -2} # The 2-digit number before '#GOGCRCSTRING'

  # Leave if installer expects 0 bin files
  if [[ $multiplier == "00" ]]; then
    echo "Exe file claims not to have bin files."
    if compgen -G "${1%.exe}-*.bin" > /dev/null; then
      echo "However, matching bin file(s) exist:"
      for i in "${1%.exe}"-*.bin; do echo "  $i"; done
      echo -e "${color_error}Unresolved dilemma, aborting.${color_reset}"
      error "$1" "bin files exist that shouldn't"
    else
      echo "Which seems true, as no matching bin files have been found."
    fi
    return
  fi

  crcstring=${crcstring::-2} # Remove the 2-digit number
  local md5hashes=${crcstring:(( - 10#$multiplier * 32 ))} # Omit characters not part of the hashes
  md5hashes=${md5hashes,,} # Set md5 hashes to lowercase
  debugmessage "Raw MD5 hashes: $md5hashes"
  echo -n "Found $((multiplier)) checksum"
  if [[ $multiplier == "01" ]]; then echo ":"; else echo "s:"; fi

  # Get the checksums
  local checksum checksums
  for i in $(seq -w 01 "$multiplier"); do
    checksum=${md5hashes:(( 32 * ((10#$i - 1)) )):32}
    [[ $checksum == "" ]] && checksum="[empty]                         "
    echo "$checksum"
    checksums+="$checksum " # Add current checksum to known checksums
  done

  # Compare the checksums
  [[ $disable_binchecksumcalculation != true ]] && echo "Verifying bin files..."
  local -i bincount=0
  for bin in "${1%.exe}"-*.bin; do
    ((bincount++))
    if [[ $disable_binchecksumcalculation != true ]]; then
      echo -n "...${bin: -29} "
      checksum=$(md5sum "$bin")
      checksum=${checksum%  *}
      if [[ $checksums == *"$checksum"* ]]; then
        echo -e "$checksum ${color_success}OK${color_reset}"
      else
        echo -e "$checksum ${color_error}Error${color_reset}"
        error "${bin##*/}" "wrong checksum"
      fi
    fi
  done

  # Throw an error when the numbers of checksums and bins differ
  if [[ ! $multiplier -eq $bincount ]]; then
    echo -e "${color_error}Warning: ${multiplier/#00/0} bin files expected, but $bincount found.${color_reset}"
    error "$1" "wrong number of bin files"
  fi
}

innocheck() {
  echo "Running innoextract check..."

  # Abort if exe is not an Inno Setup installer
  if ! innoextract --info "$1" > /dev/null; then
    echo -e "${color_error}innoextract reported errors while probing the file.${color_reset}"
    error "$1" "innoextract file probing"
    return
  fi

  # Display archive's filesize and checksum summary
  local -i filesize=0 filecount=0 sha1count=0 md5count=0
  while read -r -a array; do
    # 0: file size, 1: checksum type, 2: checksum, 3: file name
    if [[ ${array[0]} == +([[:digit:]]) ]]; then
      ((filesize+=array[0]))
      ((filecount++))
    fi
    case ${array[1]} in
      SHA-1) ((sha1count++));;
      MD5) ((md5count++));;
    esac
  done < <(innoextract --list-sizes --list-checksums --silent "$1" 2> /dev/null)
  echo "$filecount files ($((filesize/1024/1024)) MiB)"
  echo "$((sha1count + md5count)) checksums ($sha1count SHA-1, $md5count MD5)"
  if [[ ! $filecount -eq $((sha1count + md5count)) ]]; then
    echo "${color_error}Warning: Numbers of files and checksums differ.${color_reset}"
    error "$1" "innoextract checksum info"
  fi

  # Detect RAR archives
  if [[ -f "${1%.exe}"-1.bin ]]; then
    if [[ $(file "${1%.exe}"-1.bin) == *RAR* ]]; then
      echo "Bin(s) are in RAR format (innoextract does not know contents' checksums)."
      if [[ $unraroption != '--gog' ]]; then
        echo "RAR extraction (--gog option) is disabled."
      fi
      ((rarcount++))
      rarfiles+="$1"$'\n'
    fi
  fi

  # Test-extract Inno Setup archive
  if [[ $disable_extracting != true ]]; then
    echo "Test-extracting files..."
    if ! innoextract $unraroption --test --silent --progress=1 "$1"; then
      echo -e "${color_error}innoextract reported errors.${color_reset}"
      error "$1" "innoextract extraction"
      return
   else
     echo -e "Extraction successful."
   fi
 fi
}

gogcheck() {
  ((checkcount++))
  echo -e "[$checkcount] ${color_file}$1${color_reset}"
  if [[ $check_signatures == 1 ]]; then sigcheck "$1"; fi
  if [[ $check_binaries == 1 ]]; then bincheck "$1"; fi
  if [[ $check_innosetup == 1 ]]; then innocheck "$1"; fi
  echo
}

scriptresult() {
  [[ $checkcount -eq 0 ]] && exit
  if [[ $errorcount -eq 0 ]]; then
    echo -en "${color_success}"
  else
    echo -en "${color_error}"
  fi
  if [[ $errorcount -eq 1 ]]; then
    echo -e "$errorcount error${color_reset}"
  else
    echo -e "$errorcount errors${color_reset}"
  fi
  echo
  if [[ $rarcount -gt 0 ]]; then
    echo "Files with RAR archive bins:"
    echo "----------------------------"
    echo "$rarfiles"
  fi
  if [[ $errorcount -gt 0 ]]; then
    echo "Files that produced errors:"
    echo "---------------------------"
    echo -e "${color_error}$errorfiles${color_reset}"
    exit 1
  fi
  exit 0
}
trap '{ echo " Script aborted."; scriptresult; }' SIGINT # Catch CTRL-C commands

# Main loop: ------------------------------------------------------------------

shopt -s nocasematch
while [[ $1 != "" ]]; do
  if [[ -d "$1" ]]; then
    while read -r -d $'\0' exe; do
      gogcheck "$exe"
    done < <(find "$1" $maxdepth -iname "$exeprefix*.exe" -type f -print0 | sort -z)
  elif [[ -f "$1" ]] && [[ ${1##*/} == "$exeprefix"*.exe ]]; then
    gogcheck "$1"
  fi
  shift
done

scriptresult
