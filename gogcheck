#!/bin/bash

# This script tests GOG exe and bin files for authenticity and file integrity.
# It can run 3 checks: digital signature verification, bin checksum verification,
# and Inno Setup checksum verification (testing the actual game files).
# The goal is to ensure game files haven't been tempered with by a 3rd party.
#
# The following programs are required:
#   - osslsigncode (e.g. https://github.com/mtrojnar/osslsigncode)
#   - innoextract (https://constexpr.org/innoextract/)
#
# This script is considered work-in-progress and expected to have bugs.
# Please report any issues at https://github.com/hippie68/gogcheck

# As we compare Windows files, disable case matching, just in case
shopt -s nocasematch nocaseglob

# User variables; true means enabled
debug=false # Toggles appearing of debug messages
color=true

# The variables "serials", "subjects", and "issuers" are optional, pipe-delimited lists
# of known/trusted strings, which then appear colored in the signature verification.
# For "serials" and "subjects", first block is GOG, then DigiCert each.
# It is not a complete collection, and future game releases might come with new strings.
# Use this section to include additional strings seen in your known-legit files.

serials="
06F56DD38538018E9A31248796E640AB
0B2CE86937CD32092D0C003EFDF5D988
0CB6E45E4D9295AFD0DEA595E0156ACE
0DB093590538192F52B39C94119A48CB
05B5D9D6BB2960FBD330C5D6B9B7B7D2
087DE552D352D9BAF0C2B6DF6AC4C64A

0409181B5FD5BB66755343B56F955008
03019A023AFF58B16BD6D5EAE617F066
06FDF9039603ADEA000AEB3F27BBBA1B
038B96F070D9E21E55A5426792E1C83A
0FA8490615D700A0BE2176FDC5EC6DBD
039FEDEDCB795B8DED320C8919F03689
"

subjects="
/C=PL/L=Warsaw/O=GOG Sp. z o.o./CN=GOG Sp. z o.o.
/C=CY/L=Larnaca/O=GOG Limited/CN=GOG Limited
/C=CY/L=Nicosia/O=GOG Limited/CN=GOG Limited

/C=US/O=DigiCert/CN=DigiCert Timestamp Responder
/C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert Assured ID Code Signing CA-1
"

issuers="
/C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert SHA2 Assured ID Code Signing CA
/C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert Assured ID Root CA
/C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert Assured ID CA-1
"

if [[ $color == "true" ]]; then
  color_success='\033[1;92m'
  color_error='\033[91m'
  color_known='\033[32m'
  color_file='\033[1;94m'
  color_reset='\033[0;39m'
  color_debug='\033[90m'
  grep_color_success=${color_success:5:((${#color_success}-6))}
  grep_color_error=${color_error:5:((${#color_error}-6))}
  grep_color_known=${color_known:5:((${#color_known}-6))}
fi

# Script starts below

# "okstrings" and "errorstrings" are used to highlight osslsigncode's results
okstrings="Signature verification: ok"
errorstrings="MISMATCH!!!!|MISMATCH!!!|MISMATCH|failed|Failed|No signature found."

rarcount=0 # Global number of RAR archives encountered by innocheck()
rarfiles=""
errorcount=0 # Global count of file checks or unexpected
errorfiles=""
checkcount=0 # Each exe file gets a unique number - used for tracking errors faster
exeprefix='setup_'

# Escapes all regexp metacharacters in user strings for use with grep or awk
prepare_user_strings() {
  IFS=$'\n'
  for string in $1; do
    for char in \[ \] \( \) \. \^ \$ \? \* \+ \|; do
      string=${string//"$char"/"\\$char"}
    done
    result+="$string|"
  done
  echo "${result%|}"
}
serials=$(prepare_user_strings "$serials")
subjects=$(prepare_user_strings "$subjects")
issuers=$(prepare_user_strings "$issuers")

usage() {
  echo "Usage: ${0//*\/} [options] [file(s)/folder(s)]"
  echo "Checks your GOG offline installer collection for valid digital signatures and correct checksums, making sure the files are legit and have not been tempered with."
  echo "If no files or folders are specified, the current directory will be used."
  echo "If no options are specified, all checks will be run."
  echo
  echo "  The checks consist of 3 parts:"
  echo "    1. Digital signature verification for exe files"
  echo "    2. Bin file checksum verification"
  echo "    3. Inno Setup file checksum verification (actual game files packed inside exe and bin files)"
  echo
  echo "    Options:"
  echo "      -b Enables bin files checksum verification"
  echo "      -F Forces checks on all exe files (not just setup_*.exe)"
  echo "      -h Displays this help"
  echo "      -i Enables Inno Setup checksum verification"
  echo "      -s Enables exe digital signature verification"
  echo "      -- Anything following this is considered a file/folder"
  echo
  exit 0
}

# Parsing command line arguments
while [[ $1 == "-"* && ${#1} -gt 1 ]]; do
  if [[ $1 == "--" ]]; then shift; break; fi
  for ((i=1;i<${#1};i++)); do
    case ${1:i:1} in
      b) check_binaries=1;;
      F) exeprefix='';;
      h) usage;;
      i) check_innosetup=1;;
      s) check_signatures=1;;
      *) echo "${0//*\/}: invalid option: '${1:i:1}'"; usage;;
    esac
  done
  shift
done

[[ $1 == "" ]] && set -- . # If no arguments have been given, use current directory

# If no check has been enabled, enable all checks
if [[ $check_signatures$check_binaries$check_innosetup == "" ]]; then
  check_signatures=1 check_binaries=1 check_innosetup=1
fi

# Find out if required and optional commands are available
[[ $check_signatures == 1 ]] &&  ! hash osslsigncode &> /dev/null && {
  echo "osslsigncode binary not found! Which is required to verify exe signatures."
  exit 1
}
[[ $check_binaries == 1 ]] && ! hash strings &> /dev/null && {
  echo "GNU strings binary not found! Which is required to verify GOG bin file checksums."
  echo "On Debian-based distros, it comes with the package 'binutils'."
  exit 1
}
[[ $check_innosetup == 1 ]] && ! hash innoextract &> /dev/null && {
  echo "innoextract binary not found! Which is required to verify checksums of compressed files inside exe and bin files."
  echo "Download the latest version from https://constexpr.org/innoextract/"
  exit 1
}
hash sed &> /dev/null && sedfound=true # Enable optional sed if present

debugmessage() { [[ $debug == true ]] && echo -e "${color_debug}DEBUG MESSAGE: $1${color_reset}"; }

# Used for logging errors; argument format: "filename (reason)"
error() { ((errorcount++)); errorfiles+="[$checkcount] $1"$'\n'; }

# Displays the currently checked .exe file
titlebar() {
  ((checkcount++))
  echo -e "${color_file}[$checkcount] $1${color_reset}"
}

# Displays a separating line between checks
separator() {
  echo "--------------------------------------------------------------------------------"
}

# Displays a strong separating line between different .exe files
strongseparator() {
  echo "================================================================================"
}

sigcheck() {
  echo "Running signature check ..."
  result=$(osslsigncode verify "$1" 2>&1)
  returncode=$?
  # sed removes whitespace and empty lines to save space, and it removes the misleading
  # "Succeeded" message that osslsigncode creates even when there's an (perceived) error.
  echo "$result" \
     | GREP_COLOR=$grep_color_known grep --color=always -E "$serials|$subjects|$issuers|$" \
     | GREP_COLOR=$grep_color_error grep --color=always -E "$errorstrings|$" \
     | GREP_COLOR=$grep_color_success grep --color=always -E "$okstrings|$" \
     | if [[ $sedfound == true ]]; then sed -e 's/^\s\+//' -e '/^$/d' -e '/^Succeeded$/d'; else cat; fi
  if [[ $returncode != 0 || $(echo "$result" | grep -o 'No signature found.') != '' ]]; then
    error "$1 (digital signature)"
  fi
}

bincheck() {
  echo "Running bin check ..."
  local crcstring
  crcstring=$(tac "$1" | grep -a -m 1 -i -o '[[:alnum:]]*#GOGCRCSTRING')
  debugmessage "Raw GOGCRCSTRING: $crcstring"

  # Leave if no checksums found
  if [[ $crcstring == "" ]]; then
    echo -e "No bin file checksums found."
    if compgen -G "${1%.exe}-*.bin" > /dev/null; then
      echo "However, matching bin file(s) exist:"
      for i in "${1%.exe}"-*.bin; do echo "  $i"; done
      echo -e "${color_error}Without checksums, cannot verify the bin file(s)!${color_reset}"
      error "$1 (bin checksums missing)"
    else
      echo "No matching bin files found either."
      echo -e "${color_error}Is this exe a GOG installer?${color_reset}"
      error "$1 (not a GOG installer?)"
    fi
    return
  fi

  crcstring=${crcstring%#GOGCRCSTRING*} # Remove the string name, leaving numbers
  local multiplier=${crcstring: -2} # The 2-digit number before '#GOGCRCSTRING'

  # Leave if installer expects 0 bin files
  if [[ $multiplier == "00" ]]; then
    echo "Exe file claims not to have bin files."
    if compgen -G "${1%.exe}-*.bin" > /dev/null; then
      echo "However, matching bin file(s) exist:"
      for i in "${1%.exe}"-*.bin; do echo "  $i"; done
      echo -e "${color_error}Unresolved dilemma, aborting.${color_reset}"
      error "$1 (bin files exist that shouldn't)"
    else
      echo "Which seems true, as no matching bin files have been found."
    fi
    return
  fi

  crcstring=${crcstring::-2} # Remove the 2-digit number
  local md5hashes=${crcstring:(( - 10#$multiplier * 32 ))} # Omit characters not part of the hashes
  md5hashes=${md5hashes,,} # Set md5 hashes to lowercase
  debugmessage "Raw MD5 hashes: $md5hashes"
  echo -n "Found $((multiplier)) checksum"
  if [[ $multiplier == "01" ]]; then echo ":"; else echo "s:"; fi

  # Get the checksums
  local checksum checksums
  for i in $(seq -w 01 "$multiplier"); do
    checksum=${md5hashes:(( 32 * ((10#$i - 1)) )):32}
    [[ $checksum == "" ]] && checksum="[empty]                         "
    echo "  $checksum"
    checksums+="$checksum " # Add current checksum to known checksums
  done

  # Compare the checksums
  local -i bincount=0
  for bin in "${1%.exe}"-*.bin; do
    ((bincount++))
    echo "Verifying ${bin##*/}"
    checksum=$(md5sum "$bin")
    checksum=${checksum%  *}
    if [[ $checksums == *"$checksum"* ]]; then
      echo -e "  $checksum ${color_success}OK${color_reset}"
    else
      echo -e "  $checksum ${color_error}ERROR${color_reset}"
      error "${bin##*/} (wrong checksum)"
    fi
  done

  # Throw an error when the numbers of checksums and bins differ
  if [[ ! $multiplier -eq $bincount ]]; then
    echo -e "${color_error}Warning:${color_reset} $multiplier bin files expected, but $bincount found"
    error "$1 (wrong number of bin files)"
  fi
}

innocheck() {
  echo "Running innoextract check ..."

  # Abort if exe is not an Inno Setup installer
  if ! innoextract --info "$1" > /dev/null; then
    echo -e "${color_error}innoextract reported errors while probing the file.${color_reset}"
    error "$1 (innoextract file probing)"
    return
  fi

  # Display archive's filesize and checksum summary
  local -i filesize=0 filecount=0 foldercount=0 sha1count=0 md5count=0
  while read -a array; do
    # 0: file size, 1: checksum type, 2: checksum, 3: file name
    if [[ ${array[0]} == +([[:digit:]]) ]]; then
      ((filesize+=array[0]))
      ((filecount++))
    else
      [[ ${array[0]: -1} == '/' ]] && ((foldercount++)) # Skips innoextract messages, too
    fi
    case ${array[1]} in
      SHA-1) ((sha1count++));;
      MD5) ((md5count++));;
    esac
  done < <(innoextract --list-sizes --list-checksums --silent "$1")
  echo "$filecount files and $foldercount empty folders ($((filesize/1024/1024)) MiB)"
  echo "$((sha1count + md5count)) checksums ($sha1count SHA-1, $md5count MD5)"

  # Detect RAR archives
  if [[ -f "${1%.exe}"-1.bin ]]; then
    if [[ $(file "${1%.exe}"-1.bin) == *RAR* ]]; then
      echo "Bin(s) are RAR archive(s) (Inno Setup doesn't know contents' checksums)."
      ((rarcount++))
      rarfiles+="$1"$'\n'
    fi
  fi

  # Test-extract Inno Setup archive
  if ! innoextract --gog --test --silent --progress=1 "$1" 2>&1; then
    echo -e "${color_error}innoextract reported errors.${color_reset}"
    error "$1 (innoextract extraction)"
    return
  else
    echo -e "Verification complete."
  fi
}

scriptresult() {
  [[ $checkcount -eq 0 ]] && exit
  strongseparator
  echo
  if [[ $errorcount -eq 0 ]]; then
    echo -en "${color_success}"
  else
    echo -en "${color_error}"
  fi
  if [[ $errorcount -eq 1 ]]; then
    echo -e "$errorcount error${color_reset}"
  else
    echo -e "$errorcount errors${color_reset}"
  fi
  echo
  if [[ $rarcount -gt 0 ]]; then
    echo "Files with RAR archive bins:"
    echo "$rarfiles"
  fi
  if [[ $errorcount -gt 0 ]]; then
    echo "Files that produced errors:"
    echo "---------------------------"
    echo -e "${color_error}$errorfiles${color_reset}"
    exit 1
  fi
  exit 0
}

trap '{ echo " Script aborted"; scriptresult; }' SIGINT # Catch CTRL-C commands

gogcheck() {
  strongseparator
  titlebar "$1"
  if [[ $check_signatures == 1 ]]; then separator; sigcheck "$1"; fi
  if [[ $check_binaries == 1 ]]; then separator; bincheck "$1"; fi
  if [[ $check_innosetup == 1 ]]; then separator; innocheck "$1"; fi
}

# Main loop
while [[ $1 != "" ]]; do
  if [[ -d "$1" ]]; then
    for exe in "${1%/}"/"$exeprefix"*.exe; do
      [[ -f "$exe" ]] || continue
      gogcheck "$exe"
    done
  elif [[ -f "$1" ]] && [[ $1 == "$exeprefix"*.exe ]]; then
    gogcheck "$1"
  fi
  shift
done

scriptresult
